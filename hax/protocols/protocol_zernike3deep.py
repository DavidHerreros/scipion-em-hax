import os
import numpy as np


import xmipp3
from xmipp_metadata.metadata import XmippMetaData
from xmipp_metadata.image_handler import ImageHandler

import pyworkflow.protocol.params as params
from pyworkflow import VERSION_1
import pyworkflow.utils as pwutils

from pwem.protocols import ProtAnalysis3D, ProtFlexBase
from pwem.objects import Volume, ParticleFlex

from xmipp3.convert import writeSetOfParticles, matrixFromGeometry
from pyworkflow.utils import getExt, makePath
from pyworkflow.utils.path import moveFile


import hax
import hax.constants as const


class JaxProtTrainZernike3Deep(ProtAnalysis3D, ProtFlexBase):
    """Protocol to train a FlexConsensus network"""

    _label = "train - Zernike3Deep"
    _lastUpdateVersion = VERSION_1

    def _defineParams(self, form):
        # ------------------------
        # INPUT SECTION
        # ------------------------
        form.addSection(label="Input")

        form.addHidden(
            params.USE_GPU,
            params.BooleanParam,
            default=True,
            label="Use GPU for execution",
            help="This protocol has both CPU and GPU implementation.\
                                 Select the one you want to use.",
        )

        form.addHidden(
            params.GPU_LIST,
            params.StringParam,
            default="0",
            expertLevel=params.LEVEL_ADVANCED,
            label="Choose GPU IDs",
            help="Add a list of GPU devices that can be used",
        )

        form.addParam(
            "inputParticles",
            params.PointerParam,
            label="Input particles",
            pointerClass="SetOfParticles",
            important=True,
        )

        form.addParam(
            "inputVolume",
            params.PointerParam,
            pointerClass="Volume",
            label="Input volume",
            important=True,
            help="Volume to be warped toward the images.",
        )

        form.addParam(
            "boxSize",
            params.IntParam,
            default=128,
            label="Downsample particles to this box size",
            help="If your GPU is not able to fit your particles in memory, you can play with this parameter to downsample your images. "
            "In this way, you will be able to fit your particles at the expense of losing resolution in the volumes generated by the "
            "network.",
        )

        form.addParam(
            "inputVolumeMask",
            params.PointerParam,
            pointerClass="VolumeMask",
            label="Mask (optional)",
            allowsNull=True,
            help="Binary mask enclosing all mass to be moved. "
            "If empty, the volume will be auto-masked.",
        )

        form.addParam(
            "ctfType",
            params.EnumParam,
            choices=["None", "apply", "wiener", "precorrect"],
            default=0,
            label="CTF handling",
            help=(
                "None: ignore CTF\n"
                "apply: multiply projections by CTF\n"
                "wiener / precorrect: correct input images"
            ),
        )

        # ------------------------
        # TRAINING GROUP
        # ------------------------
        form.addSection(label="Training")

        form.addParam(
            "restoreCheckpoint",
            params.BooleanParam,
            default=False,
            label="Continue from previous run",
            help="During this training, this protocol saves the current state of"
            " the network. If you enable this option, the training will continue"
            " from a previous run, instead of starting from scratch.",
        )

        train = form.addGroup("Network hyperparameters")
        train.addParam(
            "latDim",
            params.IntParam,
            default=8,
            label="Latent dimension",
            help="Dimensionality of the latent space.",
        )

        train.addParam("epochs", params.IntParam, default=50, label="Epochs")

        train.addParam("batchSize", params.IntParam, default=8, label="Batch size")

        train.addParam(
            "learningRate", params.FloatParam, default=1e-4, label="Learning rate"
        )

        train.addParam(
            "lazyLoad",
            params.BooleanParam,
            default=False,
            label="Load images to RAM",
            help="Load all images to RAM (faster but uses memory).",
            expertLevel=params.LEVEL_ADVANCED,
        )

    def _createFilenameTemplates(self):
        """Centralize how files are called"""
        myDict = {
            "imgsFn": self._getExtraPath("input_particles.xmd"),
            # "predictedFn": self._getExtraPath("predicted_latents.xmd"),
            "fnVol": self._getExtraPath("volume.mrc"),
            "fnVolMask": self._getExtraPath("mask.mrc"),
        }

        self._updateFilenamesDict(myDict)

    def writeMetadataStep(self):

        fnVol = self._getFileName("fnVol")
        fnVolMask = self._getFileName("fnVolMask")
        imgsFn = self._getFileName("imgsFn")

        inputParticles = self.inputParticles.get()
        Xdim = inputParticles.getXDim()
        newXdim = self.boxSize.get()
        vol_mask_dim = newXdim

        if self.inputVolume.get():
            ih = ImageHandler()

            inputVolume = self.inputVolume.get().getFileName()
            ih.convert(self._getXmippFileName(inputVolume), fnVol)

            curr_vol_dim = ImageHandler(
                self._getXmippFileName(inputVolume)
            ).getDimensions()[-1]

            if curr_vol_dim != vol_mask_dim:
                self.runJob(
                    "xmipp_image_resize",
                    "-i %s --fourier %d " % (fnVol, vol_mask_dim),
                    numberOfMpi=1,
                    env=xmipp3.Plugin.getEnviron(),
                )

            ih.setSamplingRate(fnVol, inputParticles.getSamplingRate())

        if self.inputVolumeMask.get():
            ih = ImageHandler()
            inputMask = self.inputVolumeMask.get().getFileName()
            if inputMask:
                ih.convert(self._getXmippFileName(inputMask), fnVolMask)
                curr_mask_dim = ImageHandler(
                    self._getXmippFileName(inputMask)
                ).getDimensions()[-1]
                if curr_mask_dim != vol_mask_dim:
                    self.runJob(
                        "xmipp_image_resize",
                        "-i %s --dim %d --interp nearest" % (fnVolMask, vol_mask_dim),
                        numberOfMpi=1,
                        env=xmipp3.Plugin.getEnviron(),
                    )
        else:
            ImageHandler().createCircularMask(
                fnVolMask, boxSize=vol_mask_dim, is3D=True
            )

        writeSetOfParticles(inputParticles, imgsFn)

        # Write extra attributes (if needed)
        md = XmippMetaData(imgsFn)
        if hasattr(inputParticles.getFirstItem(), "_xmipp_subtomo_labels"):
            labels = np.asarray(
                [
                    int(particle._xmipp_subtomo_labels)
                    for particle in inputParticles.iterItems()
                ]
            )
            md[:, "subtomo_labels"] = labels
        md.write(imgsFn, overwrite=True)

        if newXdim != Xdim:
            params = "-i %s -o %s --save_metadata_stack %s --fourier %d" % (
                imgsFn,
                self._getTmpPath("scaled_particles.stk"),
                self._getExtraPath("scaled_particles.xmd"),
                newXdim,
            )
            if self.numberOfMpi.get() > 1:
                params += " --mpi_job_size %d" % int(
                    inputParticles.getSize() / self.numberOfMpi.get()
                )
            self.runJob(
                "xmipp_image_resize",
                params,
                numberOfMpi=self.numberOfMpi.get(),
                env=xmipp3.Plugin.getEnviron(),
            )
            moveFile(self._getExtraPath("scaled_particles.xmd"), imgsFn)

    def trainingStep(self):
        md_file = self._getFileName("imgsFn")
        vol_file = self._getFileName("fnVol")
        mask_file = self._getFileName("fnVolMask")
        out_path = self._getExtraPath()

        if not os.path.isdir(out_path):
            os.mkdir(out_path)

        batch_size = self.batchSize.get()
        learningRate = self.learningRate.get()
        epochs = self.epochs.get()
        latDim = self.latDim.get()

        newXdim = self.boxSize.get()
        correctionFactor = self.inputParticles.get().getXDim() / newXdim
        sr = correctionFactor * self.inputParticles.get().getSamplingRate()

        args = (
            "--md %s --sr %f --lat_dim %d --epochs %d --batch_size %d --learning_rate %s --vol %s --mask %s --output_path %s "
            % (
                md_file,
                sr,
                latDim,
                epochs,
                batch_size,
                learningRate,
                vol_file,
                mask_file,
                out_path,
            )
        )

        if self.ctfType != 0:
            if self.ctfType.get() == 1:
                args += "--ctf_type apply "
            elif self.ctfType.get() == 2:
                args += "--ctf_type wiener "
            elif self.ctfType.get() == 3:
                args += "--ctf_type precorrect "
        else:
            args += "--ctf_type None "

        if self.lazyLoad:
            args += "--load_images_to_ram "

        if self.useGpu.get():
            gpu = str(self.getGpuList()[0])
        else:
            gpu = ""

        program = hax.Plugin.getProgram("zernike3deep", gpu)

        if not os.path.isdir(self._getExtraPath("Zernike3Deep")):
            self.runJob(
                program,
                (
                    args + f"--mode train --reload {self._getExtraPath()}"
                    if self.restoreCheckpoint
                    else args + "--mode train"
                ),
                numberOfMpi=1,
            )

        self.runJob(
            program,
            args + f"--mode predict --reload {self._getExtraPath()}",
            numberOfMpi=1,
        )

    def _insertAllSteps(self):
        self._createFilenameTemplates()
        self._insertFunctionStep(self.writeMetadataStep)
        self._insertFunctionStep(self.trainingStep)

    def _summary(self):
        return []

    def _getXmippFileName(self, filename):
        if getExt(filename) == ".mrc":
            filename += ":mrc"
        return filename
